        -:    0:Source:/var/lib/gems/2.4.0/gems/ceedling-0.30.0/vendor/unity/src/unity.c
        -:    0:Graph:unity.gcno
        -:    0:Data:unity.gcda
        -:    0:Runs:12
        -:    0:Programs:4
        -:    1:/* =========================================================================
        -:    2:    Unity Project - A Test Framework for C
        -:    3:    Copyright (c) 2007-19 Mike Karlesky, Mark VanderVoord, Greg Williams
        -:    4:    [Released under MIT License. Please refer to license.txt for details]
        -:    5:============================================================================ */
        -:    6:
        -:    7:#include "unity.h"
        -:    8:#include <stddef.h>
        -:    9:
        -:   10:#ifdef AVR
        -:   11:#include <avr/pgmspace.h>
        -:   12:#else
        -:   13:#define PROGMEM
        -:   14:#endif
        -:   15:
        -:   16:/* If omitted from header, declare overrideable prototypes here so they're ready for use */
        -:   17:#ifdef UNITY_OMIT_OUTPUT_CHAR_HEADER_DECLARATION
        -:   18:void UNITY_OUTPUT_CHAR(int);
        -:   19:#endif
        -:   20:
        -:   21:/* Helpful macros for us to use here in Assert functions */
        -:   22:#define UNITY_FAIL_AND_BAIL   { Unity.CurrentTestFailed  = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); }
        -:   23:#define UNITY_IGNORE_AND_BAIL { Unity.CurrentTestIgnored = 1; UNITY_OUTPUT_FLUSH(); TEST_ABORT(); }
        -:   24:#define RETURN_IF_FAIL_OR_IGNORE if (Unity.CurrentTestFailed || Unity.CurrentTestIgnored) TEST_ABORT()
        -:   25:
        -:   26:struct UNITY_STORAGE_T Unity;
        -:   27:
        -:   28:#ifdef UNITY_OUTPUT_COLOR
        -:   29:const char PROGMEM UnityStrOk[]                            = "\033[42mOK\033[00m";
        -:   30:const char PROGMEM UnityStrPass[]                          = "\033[42mPASS\033[00m";
        -:   31:const char PROGMEM UnityStrFail[]                          = "\033[41mFAIL\033[00m";
        -:   32:const char PROGMEM UnityStrIgnore[]                        = "\033[43mIGNORE\033[00m";
        -:   33:#else
        -:   34:const char PROGMEM UnityStrOk[]                            = "OK";
        -:   35:const char PROGMEM UnityStrPass[]                          = "PASS";
        -:   36:const char PROGMEM UnityStrFail[]                          = "FAIL";
        -:   37:const char PROGMEM UnityStrIgnore[]                        = "IGNORE";
        -:   38:#endif
        -:   39:static const char PROGMEM UnityStrNull[]                   = "NULL";
        -:   40:static const char PROGMEM UnityStrSpacer[]                 = ". ";
        -:   41:static const char PROGMEM UnityStrExpected[]               = " Expected ";
        -:   42:static const char PROGMEM UnityStrWas[]                    = " Was ";
        -:   43:static const char PROGMEM UnityStrGt[]                     = " to be greater than ";
        -:   44:static const char PROGMEM UnityStrLt[]                     = " to be less than ";
        -:   45:static const char PROGMEM UnityStrOrEqual[]                = "or equal to ";
        -:   46:static const char PROGMEM UnityStrNotEqual[]               = " to be not equal to ";
        -:   47:static const char PROGMEM UnityStrElement[]                = " Element ";
        -:   48:static const char PROGMEM UnityStrByte[]                   = " Byte ";
        -:   49:static const char PROGMEM UnityStrMemory[]                 = " Memory Mismatch.";
        -:   50:static const char PROGMEM UnityStrDelta[]                  = " Values Not Within Delta ";
        -:   51:static const char PROGMEM UnityStrPointless[]              = " You Asked Me To Compare Nothing, Which Was Pointless.";
        -:   52:static const char PROGMEM UnityStrNullPointerForExpected[] = " Expected pointer to be NULL";
        -:   53:static const char PROGMEM UnityStrNullPointerForActual[]   = " Actual pointer was NULL";
        -:   54:#ifndef UNITY_EXCLUDE_FLOAT
        -:   55:static const char PROGMEM UnityStrNot[]                    = "Not ";
        -:   56:static const char PROGMEM UnityStrInf[]                    = "Infinity";
        -:   57:static const char PROGMEM UnityStrNegInf[]                 = "Negative Infinity";
        -:   58:static const char PROGMEM UnityStrNaN[]                    = "NaN";
        -:   59:static const char PROGMEM UnityStrDet[]                    = "Determinate";
        -:   60:static const char PROGMEM UnityStrInvalidFloatTrait[]      = "Invalid Float Trait";
        -:   61:#endif
        -:   62:const char PROGMEM UnityStrErrShorthand[]                  = "Unity Shorthand Support Disabled";
        -:   63:const char PROGMEM UnityStrErrFloat[]                      = "Unity Floating Point Disabled";
        -:   64:const char PROGMEM UnityStrErrDouble[]                     = "Unity Double Precision Disabled";
        -:   65:const char PROGMEM UnityStrErr64[]                         = "Unity 64-bit Support Disabled";
        -:   66:static const char PROGMEM UnityStrBreaker[]                = "-----------------------";
        -:   67:static const char PROGMEM UnityStrResultsTests[]           = " Tests ";
        -:   68:static const char PROGMEM UnityStrResultsFailures[]        = " Failures ";
        -:   69:static const char PROGMEM UnityStrResultsIgnored[]         = " Ignored ";
        -:   70:static const char PROGMEM UnityStrDetail1Name[]            = UNITY_DETAIL1_NAME " ";
        -:   71:static const char PROGMEM UnityStrDetail2Name[]            = " " UNITY_DETAIL2_NAME " ";
        -:   72:
        -:   73:/*-----------------------------------------------
        -:   74: * Pretty Printers & Test Result Output Handlers
        -:   75: *-----------------------------------------------*/
        -:   76:
        -:   77:/*-----------------------------------------------*/
        -:   78:/* Local helper function to print characters. */
     2373:   79:static void UnityPrintChar(const char* pch)
        -:   80:{
        -:   81:    /* printable characters plus CR & LF are printed */
     2373:   82:    if ((*pch <= 126) && (*pch >= 32))
        -:   83:    {
     2373:   84:        UNITY_OUTPUT_CHAR(*pch);
        -:   85:    }
        -:   86:    /* write escaped carriage returns */
    #####:   87:    else if (*pch == 13)
        -:   88:    {
    #####:   89:        UNITY_OUTPUT_CHAR('\\');
    #####:   90:        UNITY_OUTPUT_CHAR('r');
        -:   91:    }
        -:   92:    /* write escaped line feeds */
    #####:   93:    else if (*pch == 10)
        -:   94:    {
    #####:   95:        UNITY_OUTPUT_CHAR('\\');
    #####:   96:        UNITY_OUTPUT_CHAR('n');
        -:   97:    }
        -:   98:    /* unprintable characters are shown as codes */
        -:   99:    else
        -:  100:    {
    #####:  101:        UNITY_OUTPUT_CHAR('\\');
    #####:  102:        UNITY_OUTPUT_CHAR('x');
    #####:  103:        UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  104:    }
     2373:  105:}
        -:  106:
        -:  107:/*-----------------------------------------------*/
        -:  108:/* Local helper function to print ANSI escape strings e.g. "\033[42m". */
        -:  109:#ifdef UNITY_OUTPUT_COLOR
        -:  110:static UNITY_UINT UnityPrintAnsiEscapeString(const char* string)
        -:  111:{
        -:  112:    const char* pch = string;
        -:  113:    UNITY_UINT count = 0;
        -:  114:
        -:  115:    while (*pch && (*pch != 'm'))
        -:  116:    {
        -:  117:        UNITY_OUTPUT_CHAR(*pch);
        -:  118:        pch++;
        -:  119:        count++;
        -:  120:    }
        -:  121:    UNITY_OUTPUT_CHAR('m');
        -:  122:    count++;
        -:  123:
        -:  124:    return count;
        -:  125:}
        -:  126:#endif
        -:  127:
        -:  128:/*-----------------------------------------------*/
      153:  129:void UnityPrint(const char* string)
        -:  130:{
      153:  131:    const char* pch = string;
        -:  132:
      153:  133:    if (pch != NULL)
        -:  134:    {
     2679:  135:        while (*pch)
        -:  136:        {
        -:  137:#ifdef UNITY_OUTPUT_COLOR
        -:  138:            /* print ANSI escape code */
        -:  139:            if ((*pch == 27) && (*(pch + 1) == '['))
        -:  140:            {
        -:  141:                pch += UnityPrintAnsiEscapeString(pch);
        -:  142:                continue;
        -:  143:            }
        -:  144:#endif
     2373:  145:            UnityPrintChar(pch);
     2373:  146:            pch++;
        -:  147:        }
        -:  148:    }
      153:  149:}
        -:  150:/*-----------------------------------------------*/
    #####:  151:void UnityPrintLen(const char* string, const UNITY_UINT32 length)
        -:  152:{
    #####:  153:    const char* pch = string;
        -:  154:
    #####:  155:    if (pch != NULL)
        -:  156:    {
    #####:  157:        while (*pch && ((UNITY_UINT32)(pch - string) < length))
        -:  158:        {
        -:  159:            /* printable characters plus CR & LF are printed */
    #####:  160:            if ((*pch <= 126) && (*pch >= 32))
        -:  161:            {
    #####:  162:                UNITY_OUTPUT_CHAR(*pch);
        -:  163:            }
        -:  164:            /* write escaped carriage returns */
    #####:  165:            else if (*pch == 13)
        -:  166:            {
    #####:  167:                UNITY_OUTPUT_CHAR('\\');
    #####:  168:                UNITY_OUTPUT_CHAR('r');
        -:  169:            }
        -:  170:            /* write escaped line feeds */
    #####:  171:            else if (*pch == 10)
        -:  172:            {
    #####:  173:                UNITY_OUTPUT_CHAR('\\');
    #####:  174:                UNITY_OUTPUT_CHAR('n');
        -:  175:            }
        -:  176:            /* unprintable characters are shown as codes */
        -:  177:            else
        -:  178:            {
    #####:  179:                UNITY_OUTPUT_CHAR('\\');
    #####:  180:                UNITY_OUTPUT_CHAR('x');
    #####:  181:                UnityPrintNumberHex((UNITY_UINT)*pch, 2);
        -:  182:            }
    #####:  183:            pch++;
        -:  184:        }
        -:  185:    }
    #####:  186:}
        -:  187:
        -:  188:/*-----------------------------------------------*/
    #####:  189:void UnityPrintNumberByStyle(const UNITY_INT number, const UNITY_DISPLAY_STYLE_T style)
        -:  190:{
    #####:  191:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  192:    {
    #####:  193:        if (style == UNITY_DISPLAY_STYLE_CHAR)
        -:  194:        {
        -:  195:            /* printable characters plus CR & LF are printed */
    #####:  196:            UNITY_OUTPUT_CHAR('\'');
    #####:  197:            if ((number <= 126) && (number >= 32))
        -:  198:            {
    #####:  199:                UNITY_OUTPUT_CHAR((int)number);
        -:  200:            }
        -:  201:            /* write escaped carriage returns */
    #####:  202:            else if (number == 13)
        -:  203:            {
    #####:  204:                UNITY_OUTPUT_CHAR('\\');
    #####:  205:                UNITY_OUTPUT_CHAR('r');
        -:  206:            }
        -:  207:            /* write escaped line feeds */
    #####:  208:            else if (number == 10)
        -:  209:            {
    #####:  210:                UNITY_OUTPUT_CHAR('\\');
    #####:  211:                UNITY_OUTPUT_CHAR('n');
        -:  212:            }
        -:  213:            /* unprintable characters are shown as codes */
        -:  214:            else
        -:  215:            {
    #####:  216:                UNITY_OUTPUT_CHAR('\\');
    #####:  217:                UNITY_OUTPUT_CHAR('x');
    #####:  218:                UnityPrintNumberHex((UNITY_UINT)number, 2);
        -:  219:            }
    #####:  220:            UNITY_OUTPUT_CHAR('\'');
        -:  221:        }
        -:  222:        else
        -:  223:        {
    #####:  224:            UnityPrintNumber(number);
        -:  225:        }
        -:  226:    }
    #####:  227:    else if ((style & UNITY_DISPLAY_RANGE_UINT) == UNITY_DISPLAY_RANGE_UINT)
        -:  228:    {
    #####:  229:        UnityPrintNumberUnsigned((UNITY_UINT)number);
        -:  230:    }
        -:  231:    else
        -:  232:    {
    #####:  233:        UNITY_OUTPUT_CHAR('0');
    #####:  234:        UNITY_OUTPUT_CHAR('x');
    #####:  235:        UnityPrintNumberHex((UNITY_UINT)number, (char)((style & 0xF) * 2));
        -:  236:    }
    #####:  237:}
        -:  238:
        -:  239:/*-----------------------------------------------*/
       63:  240:void UnityPrintNumber(const UNITY_INT number_to_print)
        -:  241:{
       63:  242:    UNITY_UINT number = (UNITY_UINT)number_to_print;
        -:  243:
       63:  244:    if (number_to_print < 0)
        -:  245:    {
        -:  246:        /* A negative number, including MIN negative */
    #####:  247:        UNITY_OUTPUT_CHAR('-');
    #####:  248:        number = (~number) + 1;
        -:  249:    }
       63:  250:    UnityPrintNumberUnsigned(number);
       63:  251:}
        -:  252:
        -:  253:/*-----------------------------------------------
        -:  254: * basically do an itoa using as little ram as possible */
       63:  255:void UnityPrintNumberUnsigned(const UNITY_UINT number)
        -:  256:{
       63:  257:    UNITY_UINT divisor = 1;
        -:  258:
        -:  259:    /* figure out initial divisor */
      153:  260:    while (number / divisor > 9)
        -:  261:    {
       27:  262:        divisor *= 10;
        -:  263:    }
        -:  264:
        -:  265:    /* now mod and print, then divide divisor */
        -:  266:    do
        -:  267:    {
       90:  268:        UNITY_OUTPUT_CHAR((char)('0' + (number / divisor % 10)));
       90:  269:        divisor /= 10;
       90:  270:    } while (divisor > 0);
       63:  271:}
        -:  272:
        -:  273:/*-----------------------------------------------*/
    #####:  274:void UnityPrintNumberHex(const UNITY_UINT number, const char nibbles_to_print)
        -:  275:{
        -:  276:    int nibble;
    #####:  277:    char nibbles = nibbles_to_print;
        -:  278:
    #####:  279:    if ((unsigned)nibbles > UNITY_MAX_NIBBLES)
        -:  280:    {
    #####:  281:        nibbles = UNITY_MAX_NIBBLES;
        -:  282:    }
        -:  283:
    #####:  284:    while (nibbles > 0)
        -:  285:    {
    #####:  286:        nibbles--;
    #####:  287:        nibble = (int)(number >> (nibbles * 4)) & 0x0F;
    #####:  288:        if (nibble <= 9)
        -:  289:        {
    #####:  290:            UNITY_OUTPUT_CHAR((char)('0' + nibble));
        -:  291:        }
        -:  292:        else
        -:  293:        {
    #####:  294:            UNITY_OUTPUT_CHAR((char)('A' - 10 + nibble));
        -:  295:        }
        -:  296:    }
    #####:  297:}
        -:  298:
        -:  299:/*-----------------------------------------------*/
    #####:  300:void UnityPrintMask(const UNITY_UINT mask, const UNITY_UINT number)
        -:  301:{
    #####:  302:    UNITY_UINT current_bit = (UNITY_UINT)1 << (UNITY_INT_WIDTH - 1);
        -:  303:    UNITY_INT32 i;
        -:  304:
    #####:  305:    for (i = 0; i < UNITY_INT_WIDTH; i++)
        -:  306:    {
    #####:  307:        if (current_bit & mask)
        -:  308:        {
    #####:  309:            if (current_bit & number)
        -:  310:            {
    #####:  311:                UNITY_OUTPUT_CHAR('1');
        -:  312:            }
        -:  313:            else
        -:  314:            {
    #####:  315:                UNITY_OUTPUT_CHAR('0');
        -:  316:            }
        -:  317:        }
        -:  318:        else
        -:  319:        {
    #####:  320:            UNITY_OUTPUT_CHAR('X');
        -:  321:        }
    #####:  322:        current_bit = current_bit >> 1;
        -:  323:    }
    #####:  324:}
        -:  325:
        -:  326:/*-----------------------------------------------*/
        -:  327:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  328:/*
        -:  329: * This function prints a floating-point value in a format similar to
        -:  330: * printf("%.7g") on a single-precision machine or printf("%.9g") on a
        -:  331: * double-precision machine.  The 7th digit won't always be totally correct
        -:  332: * in single-precision operation (for that level of accuracy, a more
        -:  333: * complicated algorithm would be needed).
        -:  334: */
    #####:  335:void UnityPrintFloat(const UNITY_DOUBLE input_number)
        -:  336:{
        -:  337:#ifdef UNITY_INCLUDE_DOUBLE
        -:  338:    static const int sig_digits = 9;
        -:  339:    static const UNITY_INT32 min_scaled = 100000000;
        -:  340:    static const UNITY_INT32 max_scaled = 1000000000;
        -:  341:#else
        -:  342:    static const int sig_digits = 7;
        -:  343:    static const UNITY_INT32 min_scaled = 1000000;
        -:  344:    static const UNITY_INT32 max_scaled = 10000000;
        -:  345:#endif
        -:  346:
    #####:  347:    UNITY_DOUBLE number = input_number;
        -:  348:
        -:  349:    /* print minus sign (does not handle negative zero) */
    #####:  350:    if (number < 0.0f)
        -:  351:    {
    #####:  352:        UNITY_OUTPUT_CHAR('-');
    #####:  353:        number = -number;
        -:  354:    }
        -:  355:
        -:  356:    /* handle zero, NaN, and +/- infinity */
    #####:  357:    if (number == 0.0f)
        -:  358:    {
    #####:  359:        UnityPrint("0");
        -:  360:    }
    #####:  361:    else if (isnan(number))
        -:  362:    {
    #####:  363:        UnityPrint("nan");
        -:  364:    }
    #####:  365:    else if (isinf(number))
        -:  366:    {
    #####:  367:        UnityPrint("inf");
        -:  368:    }
        -:  369:    else
        -:  370:    {
    #####:  371:        UNITY_INT32 n_int = 0, n;
    #####:  372:        int exponent = 0;
        -:  373:        int decimals, digits;
    #####:  374:        char buf[16] = {0};
        -:  375:
        -:  376:        /*
        -:  377:         * Scale up or down by powers of 10.  To minimize rounding error,
        -:  378:         * start with a factor/divisor of 10^10, which is the largest
        -:  379:         * power of 10 that can be represented exactly.  Finally, compute
        -:  380:         * (exactly) the remaining power of 10 and perform one more
        -:  381:         * multiplication or division.
        -:  382:         */
    #####:  383:        if (number < 1.0f)
        -:  384:        {
    #####:  385:            UNITY_DOUBLE factor = 1.0f;
        -:  386:
    #####:  387:            while (number < (UNITY_DOUBLE)max_scaled / 1e10f)  { number *= 1e10f; exponent -= 10; }
    #####:  388:            while (number * factor < (UNITY_DOUBLE)min_scaled) { factor *= 10.0f; exponent--; }
        -:  389:
    #####:  390:            number *= factor;
        -:  391:        }
    #####:  392:        else if (number > (UNITY_DOUBLE)max_scaled)
        -:  393:        {
    #####:  394:            UNITY_DOUBLE divisor = 1.0f;
        -:  395:
    #####:  396:            while (number > (UNITY_DOUBLE)min_scaled * 1e10f)   { number  /= 1e10f; exponent += 10; }
    #####:  397:            while (number / divisor > (UNITY_DOUBLE)max_scaled) { divisor *= 10.0f; exponent++; }
        -:  398:
    #####:  399:            number /= divisor;
        -:  400:        }
        -:  401:        else
        -:  402:        {
        -:  403:            /*
        -:  404:             * In this range, we can split off the integer part before
        -:  405:             * doing any multiplications.  This reduces rounding error by
        -:  406:             * freeing up significant bits in the fractional part.
        -:  407:             */
    #####:  408:            UNITY_DOUBLE factor = 1.0f;
    #####:  409:            n_int = (UNITY_INT32)number;
    #####:  410:            number -= (UNITY_DOUBLE)n_int;
        -:  411:
    #####:  412:            while (n_int < min_scaled) { n_int *= 10; factor *= 10.0f; exponent--; }
        -:  413:
    #####:  414:            number *= factor;
        -:  415:        }
        -:  416:
        -:  417:        /* round to nearest integer */
    #####:  418:        n = ((UNITY_INT32)(number + number) + 1) / 2;
        -:  419:
        -:  420:#ifndef UNITY_ROUND_TIES_AWAY_FROM_ZERO
        -:  421:        /* round to even if exactly between two integers */
    #####:  422:        if ((n & 1) && (((UNITY_DOUBLE)n - number) == 0.5f))
    #####:  423:            n--;
        -:  424:#endif
        -:  425:
    #####:  426:        n += n_int;
        -:  427:
    #####:  428:        if (n >= max_scaled)
        -:  429:        {
    #####:  430:            n = min_scaled;
    #####:  431:            exponent++;
        -:  432:        }
        -:  433:
        -:  434:        /* determine where to place decimal point */
    #####:  435:        decimals = ((exponent <= 0) && (exponent >= -(sig_digits + 3))) ? (-exponent) : (sig_digits - 1);
    #####:  436:        exponent += decimals;
        -:  437:
        -:  438:        /* truncate trailing zeroes after decimal point */
    #####:  439:        while ((decimals > 0) && ((n % 10) == 0))
        -:  440:        {
    #####:  441:            n /= 10;
    #####:  442:            decimals--;
        -:  443:        }
        -:  444:
        -:  445:        /* build up buffer in reverse order */
    #####:  446:        digits = 0;
    #####:  447:        while ((n != 0) || (digits < (decimals + 1)))
        -:  448:        {
    #####:  449:            buf[digits++] = (char)('0' + n % 10);
    #####:  450:            n /= 10;
        -:  451:        }
    #####:  452:        while (digits > 0)
        -:  453:        {
    #####:  454:            if (digits == decimals) { UNITY_OUTPUT_CHAR('.'); }
    #####:  455:            UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  456:        }
        -:  457:
        -:  458:        /* print exponent if needed */
    #####:  459:        if (exponent != 0)
        -:  460:        {
    #####:  461:            UNITY_OUTPUT_CHAR('e');
        -:  462:
    #####:  463:            if (exponent < 0)
        -:  464:            {
    #####:  465:                UNITY_OUTPUT_CHAR('-');
    #####:  466:                exponent = -exponent;
        -:  467:            }
        -:  468:            else
        -:  469:            {
    #####:  470:                UNITY_OUTPUT_CHAR('+');
        -:  471:            }
        -:  472:
    #####:  473:            digits = 0;
    #####:  474:            while ((exponent != 0) || (digits < 2))
        -:  475:            {
    #####:  476:                buf[digits++] = (char)('0' + exponent % 10);
    #####:  477:                exponent /= 10;
        -:  478:            }
    #####:  479:            while (digits > 0)
        -:  480:            {
    #####:  481:                UNITY_OUTPUT_CHAR(buf[--digits]);
        -:  482:            }
        -:  483:        }
        -:  484:    }
    #####:  485:}
        -:  486:#endif /* ! UNITY_EXCLUDE_FLOAT_PRINT */
        -:  487:
        -:  488:/*-----------------------------------------------*/
       27:  489:static void UnityTestResultsBegin(const char* file, const UNITY_LINE_TYPE line)
        -:  490:{
        -:  491:#ifdef UNITY_OUTPUT_FOR_ECLIPSE
        -:  492:    UNITY_OUTPUT_CHAR('(');
        -:  493:    UnityPrint(file);
        -:  494:    UNITY_OUTPUT_CHAR(':');
        -:  495:    UnityPrintNumber((UNITY_INT)line);
        -:  496:    UNITY_OUTPUT_CHAR(')');
        -:  497:    UNITY_OUTPUT_CHAR(' ');
        -:  498:    UnityPrint(Unity.CurrentTestName);
        -:  499:    UNITY_OUTPUT_CHAR(':');
        -:  500:#else
        -:  501:#ifdef UNITY_OUTPUT_FOR_IAR_WORKBENCH
        -:  502:    UnityPrint("<SRCREF line=");
        -:  503:    UnityPrintNumber((UNITY_INT)line);
        -:  504:    UnityPrint(" file=\"");
        -:  505:    UnityPrint(file);
        -:  506:    UNITY_OUTPUT_CHAR('"');
        -:  507:    UNITY_OUTPUT_CHAR('>');
        -:  508:    UnityPrint(Unity.CurrentTestName);
        -:  509:    UnityPrint("</SRCREF> ");
        -:  510:#else
        -:  511:#ifdef UNITY_OUTPUT_FOR_QT_CREATOR
        -:  512:    UnityPrint("file://");
        -:  513:    UnityPrint(file);
        -:  514:    UNITY_OUTPUT_CHAR(':');
        -:  515:    UnityPrintNumber((UNITY_INT)line);
        -:  516:    UNITY_OUTPUT_CHAR(' ');
        -:  517:    UnityPrint(Unity.CurrentTestName);
        -:  518:    UNITY_OUTPUT_CHAR(':');
        -:  519:#else
       27:  520:    UnityPrint(file);
       27:  521:    UNITY_OUTPUT_CHAR(':');
       27:  522:    UnityPrintNumber((UNITY_INT)line);
       27:  523:    UNITY_OUTPUT_CHAR(':');
       27:  524:    UnityPrint(Unity.CurrentTestName);
       27:  525:    UNITY_OUTPUT_CHAR(':');
        -:  526:#endif
        -:  527:#endif
        -:  528:#endif
       27:  529:}
        -:  530:
        -:  531:/*-----------------------------------------------*/
    #####:  532:static void UnityTestResultsFailBegin(const UNITY_LINE_TYPE line)
        -:  533:{
    #####:  534:    UnityTestResultsBegin(Unity.TestFile, line);
    #####:  535:    UnityPrint(UnityStrFail);
    #####:  536:    UNITY_OUTPUT_CHAR(':');
    #####:  537:}
        -:  538:
        -:  539:/*-----------------------------------------------*/
       27:  540:void UnityConcludeTest(void)
        -:  541:{
       27:  542:    if (Unity.CurrentTestIgnored)
        -:  543:    {
       12:  544:        Unity.TestIgnores++;
        -:  545:    }
       15:  546:    else if (!Unity.CurrentTestFailed)
        -:  547:    {
       15:  548:        UnityTestResultsBegin(Unity.TestFile, Unity.CurrentTestLineNumber);
       15:  549:        UnityPrint(UnityStrPass);
        -:  550:    }
        -:  551:    else
        -:  552:    {
    #####:  553:        Unity.TestFailures++;
        -:  554:    }
        -:  555:
       27:  556:    Unity.CurrentTestFailed = 0;
       27:  557:    Unity.CurrentTestIgnored = 0;
        -:  558:    UNITY_PRINT_EXEC_TIME();
       27:  559:    UNITY_PRINT_EOL();
        -:  560:    UNITY_FLUSH_CALL();
       27:  561:}
        -:  562:
        -:  563:/*-----------------------------------------------*/
    #####:  564:static void UnityAddMsgIfSpecified(const char* msg)
        -:  565:{
    #####:  566:    if (msg)
        -:  567:    {
    #####:  568:        UnityPrint(UnityStrSpacer);
        -:  569:
        -:  570:#ifdef UNITY_PRINT_TEST_CONTEXT
        -:  571:        UNITY_PRINT_TEST_CONTEXT();
        -:  572:#endif
        -:  573:#ifndef UNITY_EXCLUDE_DETAILS
    #####:  574:        if (Unity.CurrentDetail1)
        -:  575:        {
    #####:  576:            UnityPrint(UnityStrDetail1Name);
    #####:  577:            UnityPrint(Unity.CurrentDetail1);
    #####:  578:            if (Unity.CurrentDetail2)
        -:  579:            {
    #####:  580:                UnityPrint(UnityStrDetail2Name);
    #####:  581:                UnityPrint(Unity.CurrentDetail2);
        -:  582:            }
    #####:  583:            UnityPrint(UnityStrSpacer);
        -:  584:        }
        -:  585:#endif
    #####:  586:        UnityPrint(msg);
        -:  587:    }
    #####:  588:}
        -:  589:
        -:  590:/*-----------------------------------------------*/
    #####:  591:static void UnityPrintExpectedAndActualStrings(const char* expected, const char* actual)
        -:  592:{
    #####:  593:    UnityPrint(UnityStrExpected);
    #####:  594:    if (expected != NULL)
        -:  595:    {
    #####:  596:        UNITY_OUTPUT_CHAR('\'');
    #####:  597:        UnityPrint(expected);
    #####:  598:        UNITY_OUTPUT_CHAR('\'');
        -:  599:    }
        -:  600:    else
        -:  601:    {
    #####:  602:        UnityPrint(UnityStrNull);
        -:  603:    }
    #####:  604:    UnityPrint(UnityStrWas);
    #####:  605:    if (actual != NULL)
        -:  606:    {
    #####:  607:        UNITY_OUTPUT_CHAR('\'');
    #####:  608:        UnityPrint(actual);
    #####:  609:        UNITY_OUTPUT_CHAR('\'');
        -:  610:    }
        -:  611:    else
        -:  612:    {
    #####:  613:        UnityPrint(UnityStrNull);
        -:  614:    }
    #####:  615:}
        -:  616:
        -:  617:/*-----------------------------------------------*/
    #####:  618:static void UnityPrintExpectedAndActualStringsLen(const char* expected,
        -:  619:                                                  const char* actual,
        -:  620:                                                  const UNITY_UINT32 length)
        -:  621:{
    #####:  622:    UnityPrint(UnityStrExpected);
    #####:  623:    if (expected != NULL)
        -:  624:    {
    #####:  625:        UNITY_OUTPUT_CHAR('\'');
    #####:  626:        UnityPrintLen(expected, length);
    #####:  627:        UNITY_OUTPUT_CHAR('\'');
        -:  628:    }
        -:  629:    else
        -:  630:    {
    #####:  631:        UnityPrint(UnityStrNull);
        -:  632:    }
    #####:  633:    UnityPrint(UnityStrWas);
    #####:  634:    if (actual != NULL)
        -:  635:    {
    #####:  636:        UNITY_OUTPUT_CHAR('\'');
    #####:  637:        UnityPrintLen(actual, length);
    #####:  638:        UNITY_OUTPUT_CHAR('\'');
        -:  639:    }
        -:  640:    else
        -:  641:    {
    #####:  642:        UnityPrint(UnityStrNull);
        -:  643:    }
    #####:  644:}
        -:  645:
        -:  646:/*-----------------------------------------------
        -:  647: * Assertion & Control Helpers
        -:  648: *-----------------------------------------------*/
        -:  649:
        -:  650:/*-----------------------------------------------*/
    #####:  651:static int UnityIsOneArrayNull(UNITY_INTERNAL_PTR expected,
        -:  652:                               UNITY_INTERNAL_PTR actual,
        -:  653:                               const UNITY_LINE_TYPE lineNumber,
        -:  654:                               const char* msg)
        -:  655:{
        -:  656:    /* Both are NULL or same pointer */
    #####:  657:    if (expected == actual) { return 0; }
        -:  658:
        -:  659:    /* print and return true if just expected is NULL */
    #####:  660:    if (expected == NULL)
        -:  661:    {
    #####:  662:        UnityTestResultsFailBegin(lineNumber);
    #####:  663:        UnityPrint(UnityStrNullPointerForExpected);
    #####:  664:        UnityAddMsgIfSpecified(msg);
    #####:  665:        return 1;
        -:  666:    }
        -:  667:
        -:  668:    /* print and return true if just actual is NULL */
    #####:  669:    if (actual == NULL)
        -:  670:    {
    #####:  671:        UnityTestResultsFailBegin(lineNumber);
    #####:  672:        UnityPrint(UnityStrNullPointerForActual);
    #####:  673:        UnityAddMsgIfSpecified(msg);
    #####:  674:        return 1;
        -:  675:    }
        -:  676:
    #####:  677:    return 0; /* return false if neither is NULL */
        -:  678:}
        -:  679:
        -:  680:/*-----------------------------------------------
        -:  681: * Assertion Functions
        -:  682: *-----------------------------------------------*/
        -:  683:
        -:  684:/*-----------------------------------------------*/
    #####:  685:void UnityAssertBits(const UNITY_INT mask,
        -:  686:                     const UNITY_INT expected,
        -:  687:                     const UNITY_INT actual,
        -:  688:                     const char* msg,
        -:  689:                     const UNITY_LINE_TYPE lineNumber)
        -:  690:{
    #####:  691:    RETURN_IF_FAIL_OR_IGNORE;
        -:  692:
    #####:  693:    if ((mask & expected) != (mask & actual))
        -:  694:    {
    #####:  695:        UnityTestResultsFailBegin(lineNumber);
    #####:  696:        UnityPrint(UnityStrExpected);
    #####:  697:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)expected);
    #####:  698:        UnityPrint(UnityStrWas);
    #####:  699:        UnityPrintMask((UNITY_UINT)mask, (UNITY_UINT)actual);
    #####:  700:        UnityAddMsgIfSpecified(msg);
    #####:  701:        UNITY_FAIL_AND_BAIL;
        -:  702:    }
    #####:  703:}
        -:  704:
        -:  705:/*-----------------------------------------------*/
       18:  706:void UnityAssertEqualNumber(const UNITY_INT expected,
        -:  707:                            const UNITY_INT actual,
        -:  708:                            const char* msg,
        -:  709:                            const UNITY_LINE_TYPE lineNumber,
        -:  710:                            const UNITY_DISPLAY_STYLE_T style)
        -:  711:{
       18:  712:    RETURN_IF_FAIL_OR_IGNORE;
        -:  713:
       18:  714:    if (expected != actual)
        -:  715:    {
    #####:  716:        UnityTestResultsFailBegin(lineNumber);
    #####:  717:        UnityPrint(UnityStrExpected);
    #####:  718:        UnityPrintNumberByStyle(expected, style);
    #####:  719:        UnityPrint(UnityStrWas);
    #####:  720:        UnityPrintNumberByStyle(actual, style);
    #####:  721:        UnityAddMsgIfSpecified(msg);
    #####:  722:        UNITY_FAIL_AND_BAIL;
        -:  723:    }
       18:  724:}
        -:  725:
        -:  726:/*-----------------------------------------------*/
    #####:  727:void UnityAssertGreaterOrLessOrEqualNumber(const UNITY_INT threshold,
        -:  728:                                           const UNITY_INT actual,
        -:  729:                                           const UNITY_COMPARISON_T compare,
        -:  730:                                           const char *msg,
        -:  731:                                           const UNITY_LINE_TYPE lineNumber,
        -:  732:                                           const UNITY_DISPLAY_STYLE_T style)
        -:  733:{
    #####:  734:    int failed = 0;
    #####:  735:    RETURN_IF_FAIL_OR_IGNORE;
        -:  736:
    #####:  737:    if ((threshold == actual) && (compare & UNITY_EQUAL_TO)) { return; }
    #####:  738:    if ((threshold == actual))                               { failed = 1; }
        -:  739:
    #####:  740:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -:  741:    {
    #####:  742:        if ((actual > threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  743:        if ((actual < threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  744:    }
        -:  745:    else /* UINT or HEX */
        -:  746:    {
    #####:  747:        if (((UNITY_UINT)actual > (UNITY_UINT)threshold) && (compare & UNITY_SMALLER_THAN)) { failed = 1; }
    #####:  748:        if (((UNITY_UINT)actual < (UNITY_UINT)threshold) && (compare & UNITY_GREATER_THAN)) { failed = 1; }
        -:  749:    }
        -:  750:
    #####:  751:    if (failed)
        -:  752:    {
    #####:  753:        UnityTestResultsFailBegin(lineNumber);
    #####:  754:        UnityPrint(UnityStrExpected);
    #####:  755:        UnityPrintNumberByStyle(actual, style);
    #####:  756:        if (compare & UNITY_GREATER_THAN) { UnityPrint(UnityStrGt);       }
    #####:  757:        if (compare & UNITY_SMALLER_THAN) { UnityPrint(UnityStrLt);       }
    #####:  758:        if (compare & UNITY_EQUAL_TO)     { UnityPrint(UnityStrOrEqual);  }
    #####:  759:        if (compare == UNITY_NOT_EQUAL)   { UnityPrint(UnityStrNotEqual); }
    #####:  760:        UnityPrintNumberByStyle(threshold, style);
    #####:  761:        UnityAddMsgIfSpecified(msg);
    #####:  762:        UNITY_FAIL_AND_BAIL;
        -:  763:    }
        -:  764:}
        -:  765:
        -:  766:#define UnityPrintPointlessAndBail()       \
        -:  767:{                                          \
        -:  768:    UnityTestResultsFailBegin(lineNumber); \
        -:  769:    UnityPrint(UnityStrPointless);         \
        -:  770:    UnityAddMsgIfSpecified(msg);           \
        -:  771:    UNITY_FAIL_AND_BAIL; }
        -:  772:
        -:  773:/*-----------------------------------------------*/
    #####:  774:void UnityAssertEqualIntArray(UNITY_INTERNAL_PTR expected,
        -:  775:                              UNITY_INTERNAL_PTR actual,
        -:  776:                              const UNITY_UINT32 num_elements,
        -:  777:                              const char* msg,
        -:  778:                              const UNITY_LINE_TYPE lineNumber,
        -:  779:                              const UNITY_DISPLAY_STYLE_T style,
        -:  780:                              const UNITY_FLAGS_T flags)
        -:  781:{
    #####:  782:    UNITY_UINT32 elements  = num_elements;
    #####:  783:    unsigned int length    = style & 0xF;
    #####:  784:    unsigned int increment = 0;
        -:  785:
    #####:  786:    RETURN_IF_FAIL_OR_IGNORE;
        -:  787:
    #####:  788:    if (num_elements == 0)
        -:  789:    {
    #####:  790:        UnityPrintPointlessAndBail();
        -:  791:    }
        -:  792:
    #####:  793:    if (expected == actual)
        -:  794:    {
    #####:  795:        return; /* Both are NULL or same pointer */
        -:  796:    }
        -:  797:
    #####:  798:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -:  799:    {
    #####:  800:        UNITY_FAIL_AND_BAIL;
        -:  801:    }
        -:  802:
    #####:  803:    while ((elements > 0) && (elements--))
        -:  804:    {
        -:  805:        UNITY_INT expect_val;
        -:  806:        UNITY_INT actual_val;
        -:  807:
    #####:  808:        switch (length)
        -:  809:        {
        -:  810:            case 1:
    #####:  811:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####:  812:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####:  813:                increment  = sizeof(UNITY_INT8);
    #####:  814:                break;
        -:  815:
        -:  816:            case 2:
    #####:  817:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####:  818:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####:  819:                increment  = sizeof(UNITY_INT16);
    #####:  820:                break;
        -:  821:
        -:  822:#ifdef UNITY_SUPPORT_64
        -:  823:            case 8:
        -:  824:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
        -:  825:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
        -:  826:                increment  = sizeof(UNITY_INT64);
        -:  827:                break;
        -:  828:#endif
        -:  829:
        -:  830:            default: /* default is length 4 bytes */
        -:  831:            case 4:
    #####:  832:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####:  833:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
    #####:  834:                increment  = sizeof(UNITY_INT32);
    #####:  835:                length = 4;
    #####:  836:                break;
        -:  837:        }
        -:  838:
    #####:  839:        if (expect_val != actual_val)
        -:  840:        {
    #####:  841:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -:  842:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####:  843:                UNITY_INT mask = 1;
    #####:  844:                mask = (mask << 8 * length) - 1;
    #####:  845:                expect_val &= mask;
    #####:  846:                actual_val &= mask;
        -:  847:            }
    #####:  848:            UnityTestResultsFailBegin(lineNumber);
    #####:  849:            UnityPrint(UnityStrElement);
    #####:  850:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####:  851:            UnityPrint(UnityStrExpected);
    #####:  852:            UnityPrintNumberByStyle(expect_val, style);
    #####:  853:            UnityPrint(UnityStrWas);
    #####:  854:            UnityPrintNumberByStyle(actual_val, style);
    #####:  855:            UnityAddMsgIfSpecified(msg);
    #####:  856:            UNITY_FAIL_AND_BAIL;
        -:  857:        }
        -:  858:        /* Walk through array by incrementing the pointers */
    #####:  859:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -:  860:        {
    #####:  861:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -:  862:        }
    #####:  863:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -:  864:    }
        -:  865:}
        -:  866:
        -:  867:/*-----------------------------------------------*/
        -:  868:#ifndef UNITY_EXCLUDE_FLOAT
        -:  869:/* Wrap this define in a function with variable types as float or double */
        -:  870:#define UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff)                           \
        -:  871:    if (isinf(expected) && isinf(actual) && (((expected) < 0) == ((actual) < 0))) return 1;   \
        -:  872:    if (UNITY_NAN_CHECK) return 1;                                                            \
        -:  873:    (diff) = (actual) - (expected);                                                           \
        -:  874:    if ((diff) < 0) (diff) = -(diff);                                                         \
        -:  875:    if ((delta) < 0) (delta) = -(delta);                                                      \
        -:  876:    return !(isnan(diff) || isinf(diff) || ((diff) > (delta)))
        -:  877:    /* This first part of this condition will catch any NaN or Infinite values */
        -:  878:#ifndef UNITY_NAN_NOT_EQUAL_NAN
        -:  879:  #define UNITY_NAN_CHECK isnan(expected) && isnan(actual)
        -:  880:#else
        -:  881:  #define UNITY_NAN_CHECK 0
        -:  882:#endif
        -:  883:
        -:  884:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -:  885:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  886:  {                                                               \
        -:  887:    UnityPrint(UnityStrExpected);                                 \
        -:  888:    UnityPrintFloat(expected);                                    \
        -:  889:    UnityPrint(UnityStrWas);                                      \
        -:  890:    UnityPrintFloat(actual); }
        -:  891:#else
        -:  892:  #define UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual) \
        -:  893:    UnityPrint(UnityStrDelta)
        -:  894:#endif /* UNITY_EXCLUDE_FLOAT_PRINT */
        -:  895:
        -:  896:/*-----------------------------------------------*/
        6:  897:static int UnityFloatsWithin(UNITY_FLOAT delta, UNITY_FLOAT expected, UNITY_FLOAT actual)
        -:  898:{
        -:  899:    UNITY_FLOAT diff;
        6:  900:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -:  901:}
        -:  902:
        -:  903:/*-----------------------------------------------*/
    #####:  904:void UnityAssertEqualFloatArray(UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* expected,
        -:  905:                                UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* actual,
        -:  906:                                const UNITY_UINT32 num_elements,
        -:  907:                                const char* msg,
        -:  908:                                const UNITY_LINE_TYPE lineNumber,
        -:  909:                                const UNITY_FLAGS_T flags)
        -:  910:{
    #####:  911:    UNITY_UINT32 elements = num_elements;
    #####:  912:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_expected = expected;
    #####:  913:    UNITY_PTR_ATTRIBUTE const UNITY_FLOAT* ptr_actual = actual;
        -:  914:
    #####:  915:    RETURN_IF_FAIL_OR_IGNORE;
        -:  916:
    #####:  917:    if (elements == 0)
        -:  918:    {
    #####:  919:        UnityPrintPointlessAndBail();
        -:  920:    }
        -:  921:
    #####:  922:    if (expected == actual)
        -:  923:    {
    #####:  924:        return; /* Both are NULL or same pointer */
        -:  925:    }
        -:  926:
    #####:  927:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -:  928:    {
    #####:  929:        UNITY_FAIL_AND_BAIL;
        -:  930:    }
        -:  931:
    #####:  932:    while (elements--)
        -:  933:    {
    #####:  934:        if (!UnityFloatsWithin(*ptr_expected * UNITY_FLOAT_PRECISION, *ptr_expected, *ptr_actual))
        -:  935:        {
    #####:  936:            UnityTestResultsFailBegin(lineNumber);
    #####:  937:            UnityPrint(UnityStrElement);
    #####:  938:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####:  939:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)*ptr_expected, (UNITY_DOUBLE)*ptr_actual);
    #####:  940:            UnityAddMsgIfSpecified(msg);
    #####:  941:            UNITY_FAIL_AND_BAIL;
        -:  942:        }
    #####:  943:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -:  944:        {
    #####:  945:            ptr_expected++;
        -:  946:        }
    #####:  947:        ptr_actual++;
        -:  948:    }
        -:  949:}
        -:  950:
        -:  951:/*-----------------------------------------------*/
        6:  952:void UnityAssertFloatsWithin(const UNITY_FLOAT delta,
        -:  953:                             const UNITY_FLOAT expected,
        -:  954:                             const UNITY_FLOAT actual,
        -:  955:                             const char* msg,
        -:  956:                             const UNITY_LINE_TYPE lineNumber)
        -:  957:{
        6:  958:    RETURN_IF_FAIL_OR_IGNORE;
        -:  959:
        -:  960:
        6:  961:    if (!UnityFloatsWithin(delta, expected, actual))
        -:  962:    {
    #####:  963:        UnityTestResultsFailBegin(lineNumber);
    #####:  964:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT((UNITY_DOUBLE)expected, (UNITY_DOUBLE)actual);
    #####:  965:        UnityAddMsgIfSpecified(msg);
    #####:  966:        UNITY_FAIL_AND_BAIL;
        -:  967:    }
        6:  968:}
        -:  969:
        -:  970:/*-----------------------------------------------*/
    #####:  971:void UnityAssertFloatSpecial(const UNITY_FLOAT actual,
        -:  972:                             const char* msg,
        -:  973:                             const UNITY_LINE_TYPE lineNumber,
        -:  974:                             const UNITY_FLOAT_TRAIT_T style)
        -:  975:{
    #####:  976:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
    #####:  977:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
    #####:  978:    UNITY_INT is_trait        = !should_be_trait;
    #####:  979:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -:  980:
    #####:  981:    RETURN_IF_FAIL_OR_IGNORE;
        -:  982:
    #####:  983:    switch (style)
        -:  984:    {
        -:  985:        case UNITY_FLOAT_IS_INF:
        -:  986:        case UNITY_FLOAT_IS_NOT_INF:
    #####:  987:            is_trait = isinf(actual) && (actual > 0);
    #####:  988:            break;
        -:  989:        case UNITY_FLOAT_IS_NEG_INF:
        -:  990:        case UNITY_FLOAT_IS_NOT_NEG_INF:
    #####:  991:            is_trait = isinf(actual) && (actual < 0);
    #####:  992:            break;
        -:  993:
        -:  994:        case UNITY_FLOAT_IS_NAN:
        -:  995:        case UNITY_FLOAT_IS_NOT_NAN:
    #####:  996:            is_trait = isnan(actual) ? 1 : 0;
    #####:  997:            break;
        -:  998:
        -:  999:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1000:        case UNITY_FLOAT_IS_NOT_DET:
    #####: 1001:            is_trait = !isinf(actual) && !isnan(actual);
    #####: 1002:            break;
        -: 1003:
        -: 1004:        default:
    #####: 1005:            trait_index = 0;
    #####: 1006:            trait_names[0] = UnityStrInvalidFloatTrait;
    #####: 1007:            break;
        -: 1008:    }
        -: 1009:
    #####: 1010:    if (is_trait != should_be_trait)
        -: 1011:    {
    #####: 1012:        UnityTestResultsFailBegin(lineNumber);
    #####: 1013:        UnityPrint(UnityStrExpected);
    #####: 1014:        if (!should_be_trait)
        -: 1015:        {
    #####: 1016:            UnityPrint(UnityStrNot);
        -: 1017:        }
    #####: 1018:        UnityPrint(trait_names[trait_index]);
    #####: 1019:        UnityPrint(UnityStrWas);
        -: 1020:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
    #####: 1021:        UnityPrintFloat((UNITY_DOUBLE)actual);
        -: 1022:#else
        -: 1023:        if (should_be_trait)
        -: 1024:        {
        -: 1025:            UnityPrint(UnityStrNot);
        -: 1026:        }
        -: 1027:        UnityPrint(trait_names[trait_index]);
        -: 1028:#endif
    #####: 1029:        UnityAddMsgIfSpecified(msg);
    #####: 1030:        UNITY_FAIL_AND_BAIL;
        -: 1031:    }
    #####: 1032:}
        -: 1033:
        -: 1034:#endif /* not UNITY_EXCLUDE_FLOAT */
        -: 1035:
        -: 1036:/*-----------------------------------------------*/
        -: 1037:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1038:static int UnityDoublesWithin(UNITY_DOUBLE delta, UNITY_DOUBLE expected, UNITY_DOUBLE actual)
        -: 1039:{
        -: 1040:    UNITY_DOUBLE diff;
        -: 1041:    UNITY_FLOAT_OR_DOUBLE_WITHIN(delta, expected, actual, diff);
        -: 1042:}
        -: 1043:
        -: 1044:/*-----------------------------------------------*/
        -: 1045:void UnityAssertEqualDoubleArray(UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* expected,
        -: 1046:                                 UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* actual,
        -: 1047:                                 const UNITY_UINT32 num_elements,
        -: 1048:                                 const char* msg,
        -: 1049:                                 const UNITY_LINE_TYPE lineNumber,
        -: 1050:                                 const UNITY_FLAGS_T flags)
        -: 1051:{
        -: 1052:    UNITY_UINT32 elements = num_elements;
        -: 1053:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_expected = expected;
        -: 1054:    UNITY_PTR_ATTRIBUTE const UNITY_DOUBLE* ptr_actual = actual;
        -: 1055:
        -: 1056:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1057:
        -: 1058:    if (elements == 0)
        -: 1059:    {
        -: 1060:        UnityPrintPointlessAndBail();
        -: 1061:    }
        -: 1062:
        -: 1063:    if (expected == actual)
        -: 1064:    {
        -: 1065:        return; /* Both are NULL or same pointer */
        -: 1066:    }
        -: 1067:
        -: 1068:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1069:    {
        -: 1070:        UNITY_FAIL_AND_BAIL;
        -: 1071:    }
        -: 1072:
        -: 1073:    while (elements--)
        -: 1074:    {
        -: 1075:        if (!UnityDoublesWithin(*ptr_expected * UNITY_DOUBLE_PRECISION, *ptr_expected, *ptr_actual))
        -: 1076:        {
        -: 1077:            UnityTestResultsFailBegin(lineNumber);
        -: 1078:            UnityPrint(UnityStrElement);
        -: 1079:            UnityPrintNumberUnsigned(num_elements - elements - 1);
        -: 1080:            UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(*ptr_expected, *ptr_actual);
        -: 1081:            UnityAddMsgIfSpecified(msg);
        -: 1082:            UNITY_FAIL_AND_BAIL;
        -: 1083:        }
        -: 1084:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1085:        {
        -: 1086:            ptr_expected++;
        -: 1087:        }
        -: 1088:        ptr_actual++;
        -: 1089:    }
        -: 1090:}
        -: 1091:
        -: 1092:/*-----------------------------------------------*/
        -: 1093:void UnityAssertDoublesWithin(const UNITY_DOUBLE delta,
        -: 1094:                              const UNITY_DOUBLE expected,
        -: 1095:                              const UNITY_DOUBLE actual,
        -: 1096:                              const char* msg,
        -: 1097:                              const UNITY_LINE_TYPE lineNumber)
        -: 1098:{
        -: 1099:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1100:
        -: 1101:    if (!UnityDoublesWithin(delta, expected, actual))
        -: 1102:    {
        -: 1103:        UnityTestResultsFailBegin(lineNumber);
        -: 1104:        UNITY_PRINT_EXPECTED_AND_ACTUAL_FLOAT(expected, actual);
        -: 1105:        UnityAddMsgIfSpecified(msg);
        -: 1106:        UNITY_FAIL_AND_BAIL;
        -: 1107:    }
        -: 1108:}
        -: 1109:
        -: 1110:/*-----------------------------------------------*/
        -: 1111:void UnityAssertDoubleSpecial(const UNITY_DOUBLE actual,
        -: 1112:                              const char* msg,
        -: 1113:                              const UNITY_LINE_TYPE lineNumber,
        -: 1114:                              const UNITY_FLOAT_TRAIT_T style)
        -: 1115:{
        -: 1116:    const char* trait_names[] = {UnityStrInf, UnityStrNegInf, UnityStrNaN, UnityStrDet};
        -: 1117:    UNITY_INT should_be_trait = ((UNITY_INT)style & 1);
        -: 1118:    UNITY_INT is_trait        = !should_be_trait;
        -: 1119:    UNITY_INT trait_index     = (UNITY_INT)(style >> 1);
        -: 1120:
        -: 1121:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1122:
        -: 1123:    switch (style)
        -: 1124:    {
        -: 1125:        case UNITY_FLOAT_IS_INF:
        -: 1126:        case UNITY_FLOAT_IS_NOT_INF:
        -: 1127:            is_trait = isinf(actual) && (actual > 0);
        -: 1128:            break;
        -: 1129:        case UNITY_FLOAT_IS_NEG_INF:
        -: 1130:        case UNITY_FLOAT_IS_NOT_NEG_INF:
        -: 1131:            is_trait = isinf(actual) && (actual < 0);
        -: 1132:            break;
        -: 1133:
        -: 1134:        case UNITY_FLOAT_IS_NAN:
        -: 1135:        case UNITY_FLOAT_IS_NOT_NAN:
        -: 1136:            is_trait = isnan(actual) ? 1 : 0;
        -: 1137:            break;
        -: 1138:
        -: 1139:        case UNITY_FLOAT_IS_DET: /* A determinate number is non infinite and not NaN. */
        -: 1140:        case UNITY_FLOAT_IS_NOT_DET:
        -: 1141:            is_trait = !isinf(actual) && !isnan(actual);
        -: 1142:            break;
        -: 1143:
        -: 1144:        default:
        -: 1145:            trait_index = 0;
        -: 1146:            trait_names[0] = UnityStrInvalidFloatTrait;
        -: 1147:            break;
        -: 1148:    }
        -: 1149:
        -: 1150:    if (is_trait != should_be_trait)
        -: 1151:    {
        -: 1152:        UnityTestResultsFailBegin(lineNumber);
        -: 1153:        UnityPrint(UnityStrExpected);
        -: 1154:        if (!should_be_trait)
        -: 1155:        {
        -: 1156:            UnityPrint(UnityStrNot);
        -: 1157:        }
        -: 1158:        UnityPrint(trait_names[trait_index]);
        -: 1159:        UnityPrint(UnityStrWas);
        -: 1160:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -: 1161:        UnityPrintFloat(actual);
        -: 1162:#else
        -: 1163:        if (should_be_trait)
        -: 1164:        {
        -: 1165:            UnityPrint(UnityStrNot);
        -: 1166:        }
        -: 1167:        UnityPrint(trait_names[trait_index]);
        -: 1168:#endif
        -: 1169:        UnityAddMsgIfSpecified(msg);
        -: 1170:        UNITY_FAIL_AND_BAIL;
        -: 1171:    }
        -: 1172:}
        -: 1173:
        -: 1174:#endif /* not UNITY_EXCLUDE_DOUBLE */
        -: 1175:
        -: 1176:/*-----------------------------------------------*/
    #####: 1177:void UnityAssertNumbersWithin(const UNITY_UINT delta,
        -: 1178:                              const UNITY_INT expected,
        -: 1179:                              const UNITY_INT actual,
        -: 1180:                              const char* msg,
        -: 1181:                              const UNITY_LINE_TYPE lineNumber,
        -: 1182:                              const UNITY_DISPLAY_STYLE_T style)
        -: 1183:{
    #####: 1184:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1185:
    #####: 1186:    if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1187:    {
    #####: 1188:        if (actual > expected)
        -: 1189:        {
    #####: 1190:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1191:        }
        -: 1192:        else
        -: 1193:        {
    #####: 1194:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1195:        }
        -: 1196:    }
        -: 1197:    else
        -: 1198:    {
    #####: 1199:        if ((UNITY_UINT)actual > (UNITY_UINT)expected)
        -: 1200:        {
    #####: 1201:            Unity.CurrentTestFailed = (((UNITY_UINT)actual - (UNITY_UINT)expected) > delta);
        -: 1202:        }
        -: 1203:        else
        -: 1204:        {
    #####: 1205:            Unity.CurrentTestFailed = (((UNITY_UINT)expected - (UNITY_UINT)actual) > delta);
        -: 1206:        }
        -: 1207:    }
        -: 1208:
    #####: 1209:    if (Unity.CurrentTestFailed)
        -: 1210:    {
    #####: 1211:        UnityTestResultsFailBegin(lineNumber);
    #####: 1212:        UnityPrint(UnityStrDelta);
    #####: 1213:        UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1214:        UnityPrint(UnityStrExpected);
    #####: 1215:        UnityPrintNumberByStyle(expected, style);
    #####: 1216:        UnityPrint(UnityStrWas);
    #####: 1217:        UnityPrintNumberByStyle(actual, style);
    #####: 1218:        UnityAddMsgIfSpecified(msg);
    #####: 1219:        UNITY_FAIL_AND_BAIL;
        -: 1220:    }
    #####: 1221:}
        -: 1222:
        -: 1223:/*-----------------------------------------------*/
    #####: 1224:void UnityAssertNumbersArrayWithin(const UNITY_UINT delta,
        -: 1225:                                   UNITY_INTERNAL_PTR expected,
        -: 1226:                                   UNITY_INTERNAL_PTR actual,
        -: 1227:                                   const UNITY_UINT32 num_elements,
        -: 1228:                                   const char* msg,
        -: 1229:                                   const UNITY_LINE_TYPE lineNumber,
        -: 1230:                                   const UNITY_DISPLAY_STYLE_T style,
        -: 1231:                                   const UNITY_FLAGS_T flags)
        -: 1232:{
    #####: 1233:    UNITY_UINT32 elements = num_elements;
    #####: 1234:    unsigned int length   = style & 0xF;
    #####: 1235:    unsigned int increment = 0;
        -: 1236:
    #####: 1237:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1238:
    #####: 1239:    if (num_elements == 0)
        -: 1240:    {
    #####: 1241:        UnityPrintPointlessAndBail();
        -: 1242:    }
        -: 1243:
    #####: 1244:    if (expected == actual)
        -: 1245:    {
    #####: 1246:        return; /* Both are NULL or same pointer */
        -: 1247:    }
        -: 1248:
    #####: 1249:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1250:    {
    #####: 1251:        UNITY_FAIL_AND_BAIL;
        -: 1252:    }
        -: 1253:
    #####: 1254:    while ((elements > 0) && (elements--))
        -: 1255:    {
        -: 1256:        UNITY_INT expect_val;
        -: 1257:        UNITY_INT actual_val;
        -: 1258:
    #####: 1259:        switch (length)
        -: 1260:        {
        -: 1261:            case 1:
    #####: 1262:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)expected;
    #####: 1263:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT8*)actual;
    #####: 1264:                increment  = sizeof(UNITY_INT8);
    #####: 1265:                break;
        -: 1266:
        -: 1267:            case 2:
    #####: 1268:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)expected;
    #####: 1269:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT16*)actual;
    #####: 1270:                increment  = sizeof(UNITY_INT16);
    #####: 1271:                break;
        -: 1272:
        -: 1273:#ifdef UNITY_SUPPORT_64
        -: 1274:            case 8:
        -: 1275:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)expected;
        -: 1276:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT64*)actual;
        -: 1277:                increment  = sizeof(UNITY_INT64);
        -: 1278:                break;
        -: 1279:#endif
        -: 1280:
        -: 1281:            default: /* default is length 4 bytes */
        -: 1282:            case 4:
    #####: 1283:                expect_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)expected;
    #####: 1284:                actual_val = *(UNITY_PTR_ATTRIBUTE const UNITY_INT32*)actual;
    #####: 1285:                increment  = sizeof(UNITY_INT32);
    #####: 1286:                length = 4;
    #####: 1287:                break;
        -: 1288:        }
        -: 1289:
    #####: 1290:        if ((style & UNITY_DISPLAY_RANGE_INT) == UNITY_DISPLAY_RANGE_INT)
        -: 1291:        {
    #####: 1292:            if (actual_val > expect_val)
        -: 1293:            {
    #####: 1294:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1295:            }
        -: 1296:            else
        -: 1297:            {
    #####: 1298:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1299:            }
        -: 1300:        }
        -: 1301:        else
        -: 1302:        {
    #####: 1303:            if ((UNITY_UINT)actual_val > (UNITY_UINT)expect_val)
        -: 1304:            {
    #####: 1305:                Unity.CurrentTestFailed = (((UNITY_UINT)actual_val - (UNITY_UINT)expect_val) > delta);
        -: 1306:            }
        -: 1307:            else
        -: 1308:            {
    #####: 1309:                Unity.CurrentTestFailed = (((UNITY_UINT)expect_val - (UNITY_UINT)actual_val) > delta);
        -: 1310:            }
        -: 1311:        }
        -: 1312:
    #####: 1313:        if (Unity.CurrentTestFailed)
        -: 1314:        {
    #####: 1315:            if ((style & UNITY_DISPLAY_RANGE_UINT) && (length < (UNITY_INT_WIDTH / 8)))
        -: 1316:            {   /* For UINT, remove sign extension (padding 1's) from signed type casts above */
    #####: 1317:                UNITY_INT mask = 1;
    #####: 1318:                mask = (mask << 8 * length) - 1;
    #####: 1319:                expect_val &= mask;
    #####: 1320:                actual_val &= mask;
        -: 1321:            }
    #####: 1322:            UnityTestResultsFailBegin(lineNumber);
    #####: 1323:            UnityPrint(UnityStrDelta);
    #####: 1324:            UnityPrintNumberByStyle((UNITY_INT)delta, style);
    #####: 1325:            UnityPrint(UnityStrElement);
    #####: 1326:            UnityPrintNumberUnsigned(num_elements - elements - 1);
    #####: 1327:            UnityPrint(UnityStrExpected);
    #####: 1328:            UnityPrintNumberByStyle(expect_val, style);
    #####: 1329:            UnityPrint(UnityStrWas);
    #####: 1330:            UnityPrintNumberByStyle(actual_val, style);
    #####: 1331:            UnityAddMsgIfSpecified(msg);
    #####: 1332:            UNITY_FAIL_AND_BAIL;
        -: 1333:        }
        -: 1334:        /* Walk through array by incrementing the pointers */
    #####: 1335:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1336:        {
    #####: 1337:            expected = (UNITY_INTERNAL_PTR)((const char*)expected + increment);
        -: 1338:        }
    #####: 1339:        actual = (UNITY_INTERNAL_PTR)((const char*)actual + increment);
        -: 1340:    }
        -: 1341:}
        -: 1342:
        -: 1343:/*-----------------------------------------------*/
    #####: 1344:void UnityAssertEqualString(const char* expected,
        -: 1345:                            const char* actual,
        -: 1346:                            const char* msg,
        -: 1347:                            const UNITY_LINE_TYPE lineNumber)
        -: 1348:{
        -: 1349:    UNITY_UINT32 i;
        -: 1350:
    #####: 1351:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1352:
        -: 1353:    /* if both pointers not null compare the strings */
    #####: 1354:    if (expected && actual)
        -: 1355:    {
    #####: 1356:        for (i = 0; expected[i] || actual[i]; i++)
        -: 1357:        {
    #####: 1358:            if (expected[i] != actual[i])
        -: 1359:            {
    #####: 1360:                Unity.CurrentTestFailed = 1;
    #####: 1361:                break;
        -: 1362:            }
        -: 1363:        }
        -: 1364:    }
        -: 1365:    else
        -: 1366:    { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1367:        if (expected != actual)
        -: 1368:        {
    #####: 1369:            Unity.CurrentTestFailed = 1;
        -: 1370:        }
        -: 1371:    }
        -: 1372:
    #####: 1373:    if (Unity.CurrentTestFailed)
        -: 1374:    {
    #####: 1375:        UnityTestResultsFailBegin(lineNumber);
    #####: 1376:        UnityPrintExpectedAndActualStrings(expected, actual);
    #####: 1377:        UnityAddMsgIfSpecified(msg);
    #####: 1378:        UNITY_FAIL_AND_BAIL;
        -: 1379:    }
    #####: 1380:}
        -: 1381:
        -: 1382:/*-----------------------------------------------*/
    #####: 1383:void UnityAssertEqualStringLen(const char* expected,
        -: 1384:                               const char* actual,
        -: 1385:                               const UNITY_UINT32 length,
        -: 1386:                               const char* msg,
        -: 1387:                               const UNITY_LINE_TYPE lineNumber)
        -: 1388:{
        -: 1389:    UNITY_UINT32 i;
        -: 1390:
    #####: 1391:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1392:
        -: 1393:    /* if both pointers not null compare the strings */
    #####: 1394:    if (expected && actual)
        -: 1395:    {
    #####: 1396:        for (i = 0; (i < length) && (expected[i] || actual[i]); i++)
        -: 1397:        {
    #####: 1398:            if (expected[i] != actual[i])
        -: 1399:            {
    #####: 1400:                Unity.CurrentTestFailed = 1;
    #####: 1401:                break;
        -: 1402:            }
        -: 1403:        }
        -: 1404:    }
        -: 1405:    else
        -: 1406:    { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1407:        if (expected != actual)
        -: 1408:        {
    #####: 1409:            Unity.CurrentTestFailed = 1;
        -: 1410:        }
        -: 1411:    }
        -: 1412:
    #####: 1413:    if (Unity.CurrentTestFailed)
        -: 1414:    {
    #####: 1415:        UnityTestResultsFailBegin(lineNumber);
    #####: 1416:        UnityPrintExpectedAndActualStringsLen(expected, actual, length);
    #####: 1417:        UnityAddMsgIfSpecified(msg);
    #####: 1418:        UNITY_FAIL_AND_BAIL;
        -: 1419:    }
    #####: 1420:}
        -: 1421:
        -: 1422:/*-----------------------------------------------*/
    #####: 1423:void UnityAssertEqualStringArray(UNITY_INTERNAL_PTR expected,
        -: 1424:                                 const char** actual,
        -: 1425:                                 const UNITY_UINT32 num_elements,
        -: 1426:                                 const char* msg,
        -: 1427:                                 const UNITY_LINE_TYPE lineNumber,
        -: 1428:                                 const UNITY_FLAGS_T flags)
        -: 1429:{
    #####: 1430:    UNITY_UINT32 i = 0;
    #####: 1431:    UNITY_UINT32 j = 0;
    #####: 1432:    const char* expd = NULL;
    #####: 1433:    const char* act = NULL;
        -: 1434:
    #####: 1435:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1436:
        -: 1437:    /* if no elements, it's an error */
    #####: 1438:    if (num_elements == 0)
        -: 1439:    {
    #####: 1440:        UnityPrintPointlessAndBail();
        -: 1441:    }
        -: 1442:
    #####: 1443:    if ((const void*)expected == (const void*)actual)
        -: 1444:    {
    #####: 1445:        return; /* Both are NULL or same pointer */
        -: 1446:    }
        -: 1447:
    #####: 1448:    if (UnityIsOneArrayNull((UNITY_INTERNAL_PTR)expected, (UNITY_INTERNAL_PTR)actual, lineNumber, msg))
        -: 1449:    {
    #####: 1450:        UNITY_FAIL_AND_BAIL;
        -: 1451:    }
        -: 1452:
    #####: 1453:    if (flags != UNITY_ARRAY_TO_ARRAY)
        -: 1454:    {
    #####: 1455:        expd = (const char*)expected;
        -: 1456:    }
        -: 1457:
        -: 1458:    do
        -: 1459:    {
    #####: 1460:        act = actual[j];
    #####: 1461:        if (flags == UNITY_ARRAY_TO_ARRAY)
        -: 1462:        {
    #####: 1463:            expd = ((const char* const*)expected)[j];
        -: 1464:        }
        -: 1465:
        -: 1466:        /* if both pointers not null compare the strings */
    #####: 1467:        if (expd && act)
        -: 1468:        {
    #####: 1469:            for (i = 0; expd[i] || act[i]; i++)
        -: 1470:            {
    #####: 1471:                if (expd[i] != act[i])
        -: 1472:                {
    #####: 1473:                    Unity.CurrentTestFailed = 1;
    #####: 1474:                    break;
        -: 1475:                }
        -: 1476:            }
        -: 1477:        }
        -: 1478:        else
        -: 1479:        { /* handle case of one pointers being null (if both null, test should pass) */
    #####: 1480:            if (expd != act)
        -: 1481:            {
    #####: 1482:                Unity.CurrentTestFailed = 1;
        -: 1483:            }
        -: 1484:        }
        -: 1485:
    #####: 1486:        if (Unity.CurrentTestFailed)
        -: 1487:        {
    #####: 1488:            UnityTestResultsFailBegin(lineNumber);
    #####: 1489:            if (num_elements > 1)
        -: 1490:            {
    #####: 1491:                UnityPrint(UnityStrElement);
    #####: 1492:                UnityPrintNumberUnsigned(j);
        -: 1493:            }
    #####: 1494:            UnityPrintExpectedAndActualStrings(expd, act);
    #####: 1495:            UnityAddMsgIfSpecified(msg);
    #####: 1496:            UNITY_FAIL_AND_BAIL;
        -: 1497:        }
    #####: 1498:    } while (++j < num_elements);
        -: 1499:}
        -: 1500:
        -: 1501:/*-----------------------------------------------*/
    #####: 1502:void UnityAssertEqualMemory(UNITY_INTERNAL_PTR expected,
        -: 1503:                            UNITY_INTERNAL_PTR actual,
        -: 1504:                            const UNITY_UINT32 length,
        -: 1505:                            const UNITY_UINT32 num_elements,
        -: 1506:                            const char* msg,
        -: 1507:                            const UNITY_LINE_TYPE lineNumber,
        -: 1508:                            const UNITY_FLAGS_T flags)
        -: 1509:{
    #####: 1510:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
    #####: 1511:    UNITY_PTR_ATTRIBUTE const unsigned char* ptr_act = (UNITY_PTR_ATTRIBUTE const unsigned char*)actual;
    #####: 1512:    UNITY_UINT32 elements = num_elements;
        -: 1513:    UNITY_UINT32 bytes;
        -: 1514:
    #####: 1515:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1516:
    #####: 1517:    if ((elements == 0) || (length == 0))
        -: 1518:    {
    #####: 1519:        UnityPrintPointlessAndBail();
        -: 1520:    }
        -: 1521:
    #####: 1522:    if (expected == actual)
        -: 1523:    {
    #####: 1524:        return; /* Both are NULL or same pointer */
        -: 1525:    }
        -: 1526:
    #####: 1527:    if (UnityIsOneArrayNull(expected, actual, lineNumber, msg))
        -: 1528:    {
    #####: 1529:        UNITY_FAIL_AND_BAIL;
        -: 1530:    }
        -: 1531:
    #####: 1532:    while (elements--)
        -: 1533:    {
    #####: 1534:        bytes = length;
    #####: 1535:        while (bytes--)
        -: 1536:        {
    #####: 1537:            if (*ptr_exp != *ptr_act)
        -: 1538:            {
    #####: 1539:                UnityTestResultsFailBegin(lineNumber);
    #####: 1540:                UnityPrint(UnityStrMemory);
    #####: 1541:                if (num_elements > 1)
        -: 1542:                {
    #####: 1543:                    UnityPrint(UnityStrElement);
    #####: 1544:                    UnityPrintNumberUnsigned(num_elements - elements - 1);
        -: 1545:                }
    #####: 1546:                UnityPrint(UnityStrByte);
    #####: 1547:                UnityPrintNumberUnsigned(length - bytes - 1);
    #####: 1548:                UnityPrint(UnityStrExpected);
    #####: 1549:                UnityPrintNumberByStyle(*ptr_exp, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1550:                UnityPrint(UnityStrWas);
    #####: 1551:                UnityPrintNumberByStyle(*ptr_act, UNITY_DISPLAY_STYLE_HEX8);
    #####: 1552:                UnityAddMsgIfSpecified(msg);
    #####: 1553:                UNITY_FAIL_AND_BAIL;
        -: 1554:            }
    #####: 1555:            ptr_exp++;
    #####: 1556:            ptr_act++;
        -: 1557:        }
    #####: 1558:        if (flags == UNITY_ARRAY_TO_VAL)
        -: 1559:        {
    #####: 1560:            ptr_exp = (UNITY_PTR_ATTRIBUTE const unsigned char*)expected;
        -: 1561:        }
        -: 1562:    }
        -: 1563:}
        -: 1564:
        -: 1565:/*-----------------------------------------------*/
        -: 1566:
        -: 1567:static union
        -: 1568:{
        -: 1569:    UNITY_INT8 i8;
        -: 1570:    UNITY_INT16 i16;
        -: 1571:    UNITY_INT32 i32;
        -: 1572:#ifdef UNITY_SUPPORT_64
        -: 1573:    UNITY_INT64 i64;
        -: 1574:#endif
        -: 1575:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1576:    float f;
        -: 1577:#endif
        -: 1578:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1579:    double d;
        -: 1580:#endif
        -: 1581:} UnityQuickCompare;
        -: 1582:
    #####: 1583:UNITY_INTERNAL_PTR UnityNumToPtr(const UNITY_INT num, const UNITY_UINT8 size)
        -: 1584:{
    #####: 1585:    switch(size)
        -: 1586:    {
        -: 1587:        case 1:
    #####: 1588:            UnityQuickCompare.i8 = (UNITY_INT8)num;
    #####: 1589:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i8);
        -: 1590:
        -: 1591:        case 2:
    #####: 1592:            UnityQuickCompare.i16 = (UNITY_INT16)num;
    #####: 1593:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i16);
        -: 1594:
        -: 1595:#ifdef UNITY_SUPPORT_64
        -: 1596:        case 8:
        -: 1597:            UnityQuickCompare.i64 = (UNITY_INT64)num;
        -: 1598:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i64);
        -: 1599:#endif
        -: 1600:
        -: 1601:        default: /* 4 bytes */
    #####: 1602:            UnityQuickCompare.i32 = (UNITY_INT32)num;
    #####: 1603:            return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.i32);
        -: 1604:    }
        -: 1605:}
        -: 1606:
        -: 1607:#ifndef UNITY_EXCLUDE_FLOAT
        -: 1608:/*-----------------------------------------------*/
    #####: 1609:UNITY_INTERNAL_PTR UnityFloatToPtr(const float num)
        -: 1610:{
    #####: 1611:    UnityQuickCompare.f = num;
    #####: 1612:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.f);
        -: 1613:}
        -: 1614:#endif
        -: 1615:
        -: 1616:#ifndef UNITY_EXCLUDE_DOUBLE
        -: 1617:/*-----------------------------------------------*/
        -: 1618:UNITY_INTERNAL_PTR UnityDoubleToPtr(const double num)
        -: 1619:{
        -: 1620:    UnityQuickCompare.d = num;
        -: 1621:    return (UNITY_INTERNAL_PTR)(&UnityQuickCompare.d);
        -: 1622:}
        -: 1623:#endif
        -: 1624:
        -: 1625:/*-----------------------------------------------
        -: 1626: * printf helper function
        -: 1627: *-----------------------------------------------*/
        -: 1628:#ifdef UNITY_INCLUDE_PRINT_FORMATTED
        -: 1629:static void UnityPrintFVA(const char* format, va_list va)
        -: 1630:{
        -: 1631:    const char* pch = format;
        -: 1632:    if (pch != NULL)
        -: 1633:    {
        -: 1634:        while (*pch)
        -: 1635:        {
        -: 1636:            /* format identification character */
        -: 1637:            if (*pch == '%')
        -: 1638:            {
        -: 1639:                pch++;
        -: 1640:
        -: 1641:                if (pch != NULL)
        -: 1642:                {
        -: 1643:                    switch (*pch)
        -: 1644:                    {
        -: 1645:                        case 'd':
        -: 1646:                        case 'i':
        -: 1647:                            {
        -: 1648:                                const int number = va_arg(va, int);
        -: 1649:                                UnityPrintNumber((UNITY_INT)number);
        -: 1650:                                break;
        -: 1651:                            }
        -: 1652:#ifndef UNITY_EXCLUDE_FLOAT_PRINT
        -: 1653:                        case 'f':
        -: 1654:                        case 'g':
        -: 1655:                            {
        -: 1656:                                const double number = va_arg(va, double);
        -: 1657:                                UnityPrintFloat((UNITY_DOUBLE)number);
        -: 1658:                                break;
        -: 1659:                            }
        -: 1660:#endif
        -: 1661:                        case 'u':
        -: 1662:                            {
        -: 1663:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1664:                                UnityPrintNumberUnsigned((UNITY_UINT)number);
        -: 1665:                                break;
        -: 1666:                            }
        -: 1667:                        case 'b':
        -: 1668:                            {
        -: 1669:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1670:                                const UNITY_UINT mask = (UNITY_UINT)0 - (UNITY_UINT)1;
        -: 1671:                                UNITY_OUTPUT_CHAR('0');
        -: 1672:                                UNITY_OUTPUT_CHAR('b');
        -: 1673:                                UnityPrintMask(mask, (UNITY_UINT)number);
        -: 1674:                                break;
        -: 1675:                            }
        -: 1676:                        case 'x':
        -: 1677:                        case 'X':
        -: 1678:                        case 'p':
        -: 1679:                            {
        -: 1680:                                const unsigned int number = va_arg(va, unsigned int);
        -: 1681:                                UNITY_OUTPUT_CHAR('0');
        -: 1682:                                UNITY_OUTPUT_CHAR('x');
        -: 1683:                                UnityPrintNumberHex((UNITY_UINT)number, 8);
        -: 1684:                                break;
        -: 1685:                            }
        -: 1686:                        case 'c':
        -: 1687:                            {
        -: 1688:                                const int ch = va_arg(va, int);
        -: 1689:                                UnityPrintChar((const char *)&ch);
        -: 1690:                                break;
        -: 1691:                            }
        -: 1692:                        case 's':
        -: 1693:                            {
        -: 1694:                                const char * string = va_arg(va, const char *);
        -: 1695:                                UnityPrint(string);
        -: 1696:                                break;
        -: 1697:                            }
        -: 1698:                        case '%':
        -: 1699:                            {
        -: 1700:                                UnityPrintChar(pch);
        -: 1701:                                break;
        -: 1702:                            }
        -: 1703:                        default:
        -: 1704:                            {
        -: 1705:                                /* print the unknown format character */
        -: 1706:                                UNITY_OUTPUT_CHAR('%');
        -: 1707:                                UnityPrintChar(pch);
        -: 1708:                                break;
        -: 1709:                            }
        -: 1710:                    }
        -: 1711:                }
        -: 1712:            }
        -: 1713:#ifdef UNITY_OUTPUT_COLOR
        -: 1714:            /* print ANSI escape code */
        -: 1715:            else if ((*pch == 27) && (*(pch + 1) == '['))
        -: 1716:            {
        -: 1717:                pch += UnityPrintAnsiEscapeString(pch);
        -: 1718:                continue;
        -: 1719:            }
        -: 1720:#endif
        -: 1721:            else if (*pch == '\n')
        -: 1722:            {
        -: 1723:                UNITY_PRINT_EOL();
        -: 1724:            }
        -: 1725:            else
        -: 1726:            {
        -: 1727:                UnityPrintChar(pch);
        -: 1728:            }
        -: 1729:
        -: 1730:            pch++;
        -: 1731:        }
        -: 1732:    }
        -: 1733:}
        -: 1734:
        -: 1735:void UnityPrintF(const UNITY_LINE_TYPE line, const char* format, ...)
        -: 1736:{
        -: 1737:    UnityTestResultsBegin(Unity.TestFile, line);
        -: 1738:    UnityPrint("INFO");
        -: 1739:    if(format != NULL)
        -: 1740:    {
        -: 1741:        UnityPrint(": ");
        -: 1742:        va_list va;
        -: 1743:        va_start(va, format);
        -: 1744:        UnityPrintFVA(format, va);
        -: 1745:        va_end(va);
        -: 1746:    }
        -: 1747:    UNITY_PRINT_EOL();
        -: 1748:}
        -: 1749:#endif /* ! UNITY_INCLUDE_PRINT_FORMATTED */
        -: 1750:
        -: 1751:
        -: 1752:/*-----------------------------------------------
        -: 1753: * Control Functions
        -: 1754: *-----------------------------------------------*/
        -: 1755:
        -: 1756:/*-----------------------------------------------*/
    #####: 1757:void UnityFail(const char* msg, const UNITY_LINE_TYPE line)
        -: 1758:{
    #####: 1759:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1760:
    #####: 1761:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 1762:    UnityPrint(UnityStrFail);
    #####: 1763:    if (msg != NULL)
        -: 1764:    {
    #####: 1765:        UNITY_OUTPUT_CHAR(':');
        -: 1766:
        -: 1767:#ifdef UNITY_PRINT_TEST_CONTEXT
        -: 1768:        UNITY_PRINT_TEST_CONTEXT();
        -: 1769:#endif
        -: 1770:#ifndef UNITY_EXCLUDE_DETAILS
    #####: 1771:        if (Unity.CurrentDetail1)
        -: 1772:        {
    #####: 1773:            UnityPrint(UnityStrDetail1Name);
    #####: 1774:            UnityPrint(Unity.CurrentDetail1);
    #####: 1775:            if (Unity.CurrentDetail2)
        -: 1776:            {
    #####: 1777:                UnityPrint(UnityStrDetail2Name);
    #####: 1778:                UnityPrint(Unity.CurrentDetail2);
        -: 1779:            }
    #####: 1780:            UnityPrint(UnityStrSpacer);
        -: 1781:        }
        -: 1782:#endif
    #####: 1783:        if (msg[0] != ' ')
        -: 1784:        {
    #####: 1785:            UNITY_OUTPUT_CHAR(' ');
        -: 1786:        }
    #####: 1787:        UnityPrint(msg);
        -: 1788:    }
        -: 1789:
    #####: 1790:    UNITY_FAIL_AND_BAIL;
        -: 1791:}
        -: 1792:
        -: 1793:/*-----------------------------------------------*/
       12: 1794:void UnityIgnore(const char* msg, const UNITY_LINE_TYPE line)
        -: 1795:{
       12: 1796:    RETURN_IF_FAIL_OR_IGNORE;
        -: 1797:
       12: 1798:    UnityTestResultsBegin(Unity.TestFile, line);
       12: 1799:    UnityPrint(UnityStrIgnore);
       12: 1800:    if (msg != NULL)
        -: 1801:    {
       12: 1802:        UNITY_OUTPUT_CHAR(':');
       12: 1803:        UNITY_OUTPUT_CHAR(' ');
       12: 1804:        UnityPrint(msg);
        -: 1805:    }
       12: 1806:    UNITY_IGNORE_AND_BAIL;
        -: 1807:}
        -: 1808:
        -: 1809:/*-----------------------------------------------*/
    #####: 1810:void UnityMessage(const char* msg, const UNITY_LINE_TYPE line)
        -: 1811:{
    #####: 1812:    UnityTestResultsBegin(Unity.TestFile, line);
    #####: 1813:    UnityPrint("INFO");
    #####: 1814:    if (msg != NULL)
        -: 1815:    {
    #####: 1816:      UNITY_OUTPUT_CHAR(':');
    #####: 1817:      UNITY_OUTPUT_CHAR(' ');
    #####: 1818:      UnityPrint(msg);
        -: 1819:    }
    #####: 1820:    UNITY_PRINT_EOL();
    #####: 1821:}
        -: 1822:
        -: 1823:/*-----------------------------------------------*/
        -: 1824:/* If we have not defined our own test runner, then include our default test runner to make life easier */
        -: 1825:#ifndef UNITY_SKIP_DEFAULT_RUNNER
    #####: 1826:void UnityDefaultTestRun(UnityTestFunction Func, const char* FuncName, const int FuncLineNum)
        -: 1827:{
    #####: 1828:    Unity.CurrentTestName = FuncName;
    #####: 1829:    Unity.CurrentTestLineNumber = (UNITY_LINE_TYPE)FuncLineNum;
    #####: 1830:    Unity.NumberOfTests++;
    #####: 1831:    UNITY_CLR_DETAILS();
        -: 1832:    UNITY_EXEC_TIME_START();
    #####: 1833:    if (TEST_PROTECT())
        -: 1834:    {
    #####: 1835:        setUp();
    #####: 1836:        Func();
        -: 1837:    }
    #####: 1838:    if (TEST_PROTECT())
        -: 1839:    {
    #####: 1840:        tearDown();
        -: 1841:    }
        -: 1842:    UNITY_EXEC_TIME_STOP();
    #####: 1843:    UnityConcludeTest();
    #####: 1844:}
        -: 1845:#endif
        -: 1846:
        -: 1847:/*-----------------------------------------------*/
    #####: 1848:void UnitySetTestFile(const char* filename)
        -: 1849:{
    #####: 1850:	Unity.TestFile = filename;
    #####: 1851:}
        -: 1852:
        -: 1853:/*-----------------------------------------------*/
       12: 1854:void UnityBegin(const char* filename)
        -: 1855:{
       12: 1856:    Unity.TestFile = filename;
       12: 1857:    Unity.CurrentTestName = NULL;
       12: 1858:    Unity.CurrentTestLineNumber = 0;
       12: 1859:    Unity.NumberOfTests = 0;
       12: 1860:    Unity.TestFailures = 0;
       12: 1861:    Unity.TestIgnores = 0;
       12: 1862:    Unity.CurrentTestFailed = 0;
       12: 1863:    Unity.CurrentTestIgnored = 0;
        -: 1864:
       12: 1865:    UNITY_CLR_DETAILS();
        -: 1866:    UNITY_OUTPUT_START();
       12: 1867:}
        -: 1868:
        -: 1869:/*-----------------------------------------------*/
       12: 1870:int UnityEnd(void)
        -: 1871:{
       12: 1872:    UNITY_PRINT_EOL();
       12: 1873:    UnityPrint(UnityStrBreaker);
       12: 1874:    UNITY_PRINT_EOL();
       12: 1875:    UnityPrintNumber((UNITY_INT)(Unity.NumberOfTests));
       12: 1876:    UnityPrint(UnityStrResultsTests);
       12: 1877:    UnityPrintNumber((UNITY_INT)(Unity.TestFailures));
       12: 1878:    UnityPrint(UnityStrResultsFailures);
       12: 1879:    UnityPrintNumber((UNITY_INT)(Unity.TestIgnores));
       12: 1880:    UnityPrint(UnityStrResultsIgnored);
       12: 1881:    UNITY_PRINT_EOL();
       12: 1882:    if (Unity.TestFailures == 0U)
        -: 1883:    {
       12: 1884:        UnityPrint(UnityStrOk);
        -: 1885:    }
        -: 1886:    else
        -: 1887:    {
    #####: 1888:        UnityPrint(UnityStrFail);
        -: 1889:#ifdef UNITY_DIFFERENTIATE_FINAL_FAIL
        -: 1890:        UNITY_OUTPUT_CHAR('E'); UNITY_OUTPUT_CHAR('D');
        -: 1891:#endif
        -: 1892:    }
       12: 1893:    UNITY_PRINT_EOL();
        -: 1894:    UNITY_FLUSH_CALL();
        -: 1895:    UNITY_OUTPUT_COMPLETE();
       12: 1896:    return (int)(Unity.TestFailures);
        -: 1897:}
        -: 1898:
        -: 1899:/*-----------------------------------------------
        -: 1900: * Command Line Argument Support
        -: 1901: *-----------------------------------------------*/
        -: 1902:#ifdef UNITY_USE_COMMAND_LINE_ARGS
        -: 1903:
        -: 1904:char* UnityOptionIncludeNamed = NULL;
        -: 1905:char* UnityOptionExcludeNamed = NULL;
        -: 1906:int UnityVerbosity            = 1;
        -: 1907:
        -: 1908:/*-----------------------------------------------*/
        -: 1909:int UnityParseOptions(int argc, char** argv)
        -: 1910:{
        -: 1911:    int i;
        -: 1912:    UnityOptionIncludeNamed = NULL;
        -: 1913:    UnityOptionExcludeNamed = NULL;
        -: 1914:
        -: 1915:    for (i = 1; i < argc; i++)
        -: 1916:    {
        -: 1917:        if (argv[i][0] == '-')
        -: 1918:        {
        -: 1919:            switch (argv[i][1])
        -: 1920:            {
        -: 1921:                case 'l': /* list tests */
        -: 1922:                    return -1;
        -: 1923:                case 'n': /* include tests with name including this string */
        -: 1924:                case 'f': /* an alias for -n */
        -: 1925:                    if (argv[i][2] == '=')
        -: 1926:                    {
        -: 1927:                        UnityOptionIncludeNamed = &argv[i][3];
        -: 1928:                    }
        -: 1929:                    else if (++i < argc)
        -: 1930:                    {
        -: 1931:                        UnityOptionIncludeNamed = argv[i];
        -: 1932:                    }
        -: 1933:                    else
        -: 1934:                    {
        -: 1935:                        UnityPrint("ERROR: No Test String to Include Matches For");
        -: 1936:                        UNITY_PRINT_EOL();
        -: 1937:                        return 1;
        -: 1938:                    }
        -: 1939:                    break;
        -: 1940:                case 'q': /* quiet */
        -: 1941:                    UnityVerbosity = 0;
        -: 1942:                    break;
        -: 1943:                case 'v': /* verbose */
        -: 1944:                    UnityVerbosity = 2;
        -: 1945:                    break;
        -: 1946:                case 'x': /* exclude tests with name including this string */
        -: 1947:                    if (argv[i][2] == '=')
        -: 1948:                    {
        -: 1949:                        UnityOptionExcludeNamed = &argv[i][3];
        -: 1950:                    }
        -: 1951:                    else if (++i < argc)
        -: 1952:                    {
        -: 1953:                        UnityOptionExcludeNamed = argv[i];
        -: 1954:                    }
        -: 1955:                    else
        -: 1956:                    {
        -: 1957:                        UnityPrint("ERROR: No Test String to Exclude Matches For");
        -: 1958:                        UNITY_PRINT_EOL();
        -: 1959:                        return 1;
        -: 1960:                    }
        -: 1961:                    break;
        -: 1962:                default:
        -: 1963:                    UnityPrint("ERROR: Unknown Option ");
        -: 1964:                    UNITY_OUTPUT_CHAR(argv[i][1]);
        -: 1965:                    UNITY_PRINT_EOL();
        -: 1966:                    return 1;
        -: 1967:            }
        -: 1968:        }
        -: 1969:    }
        -: 1970:
        -: 1971:    return 0;
        -: 1972:}
        -: 1973:
        -: 1974:/*-----------------------------------------------*/
        -: 1975:int IsStringInBiggerString(const char* longstring, const char* shortstring)
        -: 1976:{
        -: 1977:    const char* lptr = longstring;
        -: 1978:    const char* sptr = shortstring;
        -: 1979:    const char* lnext = lptr;
        -: 1980:
        -: 1981:    if (*sptr == '*')
        -: 1982:    {
        -: 1983:        return 1;
        -: 1984:    }
        -: 1985:
        -: 1986:    while (*lptr)
        -: 1987:    {
        -: 1988:        lnext = lptr + 1;
        -: 1989:
        -: 1990:        /* If they current bytes match, go on to the next bytes */
        -: 1991:        while (*lptr && *sptr && (*lptr == *sptr))
        -: 1992:        {
        -: 1993:            lptr++;
        -: 1994:            sptr++;
        -: 1995:
        -: 1996:            /* We're done if we match the entire string or up to a wildcard */
        -: 1997:            if (*sptr == '*')
        -: 1998:                return 1;
        -: 1999:            if (*sptr == ',')
        -: 2000:                return 1;
        -: 2001:            if (*sptr == '"')
        -: 2002:                return 1;
        -: 2003:            if (*sptr == '\'')
        -: 2004:                return 1;
        -: 2005:            if (*sptr == ':')
        -: 2006:                return 2;
        -: 2007:            if (*sptr == 0)
        -: 2008:                return 1;
        -: 2009:        }
        -: 2010:
        -: 2011:        /* Otherwise we start in the long pointer 1 character further and try again */
        -: 2012:        lptr = lnext;
        -: 2013:        sptr = shortstring;
        -: 2014:    }
        -: 2015:
        -: 2016:    return 0;
        -: 2017:}
        -: 2018:
        -: 2019:/*-----------------------------------------------*/
        -: 2020:int UnityStringArgumentMatches(const char* str)
        -: 2021:{
        -: 2022:    int retval;
        -: 2023:    const char* ptr1;
        -: 2024:    const char* ptr2;
        -: 2025:    const char* ptrf;
        -: 2026:
        -: 2027:    /* Go through the options and get the substrings for matching one at a time */
        -: 2028:    ptr1 = str;
        -: 2029:    while (ptr1[0] != 0)
        -: 2030:    {
        -: 2031:        if ((ptr1[0] == '"') || (ptr1[0] == '\''))
        -: 2032:        {
        -: 2033:            ptr1++;
        -: 2034:        }
        -: 2035:
        -: 2036:        /* look for the start of the next partial */
        -: 2037:        ptr2 = ptr1;
        -: 2038:        ptrf = 0;
        -: 2039:        do
        -: 2040:        {
        -: 2041:            ptr2++;
        -: 2042:            if ((ptr2[0] == ':') && (ptr2[1] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','))
        -: 2043:            {
        -: 2044:                ptrf = &ptr2[1];
        -: 2045:            }
        -: 2046:        } while ((ptr2[0] != 0) && (ptr2[0] != '\'') && (ptr2[0] != '"') && (ptr2[0] != ','));
        -: 2047:
        -: 2048:        while ((ptr2[0] != 0) && ((ptr2[0] == ':') || (ptr2[0] == '\'') || (ptr2[0] == '"') || (ptr2[0] == ',')))
        -: 2049:        {
        -: 2050:            ptr2++;
        -: 2051:        }
        -: 2052:
        -: 2053:        /* done if complete filename match */
        -: 2054:        retval = IsStringInBiggerString(Unity.TestFile, ptr1);
        -: 2055:        if (retval == 1)
        -: 2056:        {
        -: 2057:            return retval;
        -: 2058:        }
        -: 2059:
        -: 2060:        /* done if testname match after filename partial match */
        -: 2061:        if ((retval == 2) && (ptrf != 0))
        -: 2062:        {
        -: 2063:            if (IsStringInBiggerString(Unity.CurrentTestName, ptrf))
        -: 2064:            {
        -: 2065:                return 1;
        -: 2066:            }
        -: 2067:        }
        -: 2068:
        -: 2069:        /* done if complete testname match */
        -: 2070:        if (IsStringInBiggerString(Unity.CurrentTestName, ptr1) == 1)
        -: 2071:        {
        -: 2072:            return 1;
        -: 2073:        }
        -: 2074:
        -: 2075:        ptr1 = ptr2;
        -: 2076:    }
        -: 2077:
        -: 2078:    /* we couldn't find a match for any substrings */
        -: 2079:    return 0;
        -: 2080:}
        -: 2081:
        -: 2082:/*-----------------------------------------------*/
        -: 2083:int UnityTestMatches(void)
        -: 2084:{
        -: 2085:    /* Check if this test name matches the included test pattern */
        -: 2086:    int retval;
        -: 2087:    if (UnityOptionIncludeNamed)
        -: 2088:    {
        -: 2089:        retval = UnityStringArgumentMatches(UnityOptionIncludeNamed);
        -: 2090:    }
        -: 2091:    else
        -: 2092:    {
        -: 2093:        retval = 1;
        -: 2094:    }
        -: 2095:
        -: 2096:    /* Check if this test name matches the excluded test pattern */
        -: 2097:    if (UnityOptionExcludeNamed)
        -: 2098:    {
        -: 2099:        if (UnityStringArgumentMatches(UnityOptionExcludeNamed))
        -: 2100:        {
        -: 2101:            retval = 0;
        -: 2102:        }
        -: 2103:    }
        -: 2104:
        -: 2105:    return retval;
        -: 2106:}
        -: 2107:
        -: 2108:#endif /* UNITY_USE_COMMAND_LINE_ARGS */
        -: 2109:/*-----------------------------------------------*/
